/**
 * This file was automatically generated by @cosmwasm/ts-codegen@0.13.4.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run the @cosmwasm/ts-codegen generate command to regenerate this file.
 */
import { CosmWasmClient, SigningCosmWasmClient, ExecuteResult } from "@cosmjs/cosmwasm-stargate";
import { Coin, StdFee } from "@cosmjs/amino";
import { MintRule, BadgeResponse, Metadata, BadgesResponse, ConfigResponse, KeyResponse, KeysResponse, OwnerResponse, OwnersResponse } from "./Hub.types";
export interface HubReadOnlyInterface {
    contractAddress: string;
    config: () => Promise<ConfigResponse>;
    badge: ({ id }: {
        id: number;
    }) => Promise<BadgeResponse>;
    badges: ({ limit, startAfter, }: {
        limit?: number;
        startAfter?: number;
    }) => Promise<BadgesResponse>;
    key: ({ id, pubkey }: {
        id: number;
        pubkey: string;
    }) => Promise<KeyResponse>;
    keys: ({ id, limit, startAfter, }: {
        id: number;
        limit?: number;
        startAfter?: string;
    }) => Promise<KeysResponse>;
    owner: ({ id, user }: {
        id: number;
        user: string;
    }) => Promise<OwnerResponse>;
    owners: ({ id, limit, startAfter, }: {
        id: number;
        limit?: number;
        startAfter?: string;
    }) => Promise<OwnersResponse>;
}
export declare class HubQueryClient implements HubReadOnlyInterface {
    client: CosmWasmClient;
    contractAddress: string;
    constructor(client: CosmWasmClient, contractAddress: string);
    config: () => Promise<ConfigResponse>;
    badge: ({ id }: {
        id: number;
    }) => Promise<BadgeResponse>;
    badges: ({ limit, startAfter, }: {
        limit?: number;
        startAfter?: number;
    }) => Promise<BadgesResponse>;
    key: ({ id, pubkey }: {
        id: number;
        pubkey: string;
    }) => Promise<KeyResponse>;
    keys: ({ id, limit, startAfter, }: {
        id: number;
        limit?: number;
        startAfter?: string;
    }) => Promise<KeysResponse>;
    owner: ({ id, user }: {
        id: number;
        user: string;
    }) => Promise<OwnerResponse>;
    owners: ({ id, limit, startAfter, }: {
        id: number;
        limit?: number;
        startAfter?: string;
    }) => Promise<OwnersResponse>;
}
export interface HubInterface extends HubReadOnlyInterface {
    contractAddress: string;
    sender: string;
    createBadge: ({ expiry, manager, maxSupply, metadata, rule, transferrable, }: {
        expiry?: number;
        manager: string;
        maxSupply?: number;
        metadata: Metadata;
        rule: MintRule;
        transferrable: boolean;
    }, fee?: number | StdFee | "auto", memo?: string, funds?: Coin[]) => Promise<ExecuteResult>;
    editBadge: ({ id, metadata, }: {
        id: number;
        metadata: Metadata;
    }, fee?: number | StdFee | "auto", memo?: string, funds?: Coin[]) => Promise<ExecuteResult>;
    addKeys: ({ id, keys, }: {
        id: number;
        keys: string[];
    }, fee?: number | StdFee | "auto", memo?: string, funds?: Coin[]) => Promise<ExecuteResult>;
    purgeKeys: ({ id, limit, }: {
        id: number;
        limit?: number;
    }, fee?: number | StdFee | "auto", memo?: string, funds?: Coin[]) => Promise<ExecuteResult>;
    purgeOwners: ({ id, limit, }: {
        id: number;
        limit?: number;
    }, fee?: number | StdFee | "auto", memo?: string, funds?: Coin[]) => Promise<ExecuteResult>;
    mintByMinter: ({ id, owners, }: {
        id: number;
        owners: string[];
    }, fee?: number | StdFee | "auto", memo?: string, funds?: Coin[]) => Promise<ExecuteResult>;
    mintByKey: ({ id, owner, signature, }: {
        id: number;
        owner: string;
        signature: string;
    }, fee?: number | StdFee | "auto", memo?: string, funds?: Coin[]) => Promise<ExecuteResult>;
    mintByKeys: ({ id, owner, pubkey, signature, }: {
        id: number;
        owner: string;
        pubkey: string;
        signature: string;
    }, fee?: number | StdFee | "auto", memo?: string, funds?: Coin[]) => Promise<ExecuteResult>;
    setNft: ({ nft, }: {
        nft: string;
    }, fee?: number | StdFee | "auto", memo?: string, funds?: Coin[]) => Promise<ExecuteResult>;
}
export declare class HubClient extends HubQueryClient implements HubInterface {
    client: SigningCosmWasmClient;
    sender: string;
    contractAddress: string;
    constructor(client: SigningCosmWasmClient, sender: string, contractAddress: string);
    createBadge: ({ expiry, manager, maxSupply, metadata, rule, transferrable, }: {
        expiry?: number;
        manager: string;
        maxSupply?: number;
        metadata: Metadata;
        rule: MintRule;
        transferrable: boolean;
    }, fee?: number | StdFee | "auto", memo?: string, funds?: Coin[]) => Promise<ExecuteResult>;
    editBadge: ({ id, metadata, }: {
        id: number;
        metadata: Metadata;
    }, fee?: number | StdFee | "auto", memo?: string, funds?: Coin[]) => Promise<ExecuteResult>;
    addKeys: ({ id, keys, }: {
        id: number;
        keys: string[];
    }, fee?: number | StdFee | "auto", memo?: string, funds?: Coin[]) => Promise<ExecuteResult>;
    purgeKeys: ({ id, limit, }: {
        id: number;
        limit?: number;
    }, fee?: number | StdFee | "auto", memo?: string, funds?: Coin[]) => Promise<ExecuteResult>;
    purgeOwners: ({ id, limit, }: {
        id: number;
        limit?: number;
    }, fee?: number | StdFee | "auto", memo?: string, funds?: Coin[]) => Promise<ExecuteResult>;
    mintByMinter: ({ id, owners, }: {
        id: number;
        owners: string[];
    }, fee?: number | StdFee | "auto", memo?: string, funds?: Coin[]) => Promise<ExecuteResult>;
    mintByKey: ({ id, owner, signature, }: {
        id: number;
        owner: string;
        signature: string;
    }, fee?: number | StdFee | "auto", memo?: string, funds?: Coin[]) => Promise<ExecuteResult>;
    mintByKeys: ({ id, owner, pubkey, signature, }: {
        id: number;
        owner: string;
        pubkey: string;
        signature: string;
    }, fee?: number | StdFee | "auto", memo?: string, funds?: Coin[]) => Promise<ExecuteResult>;
    setNft: ({ nft, }: {
        nft: string;
    }, fee?: number | StdFee | "auto", memo?: string, funds?: Coin[]) => Promise<ExecuteResult>;
}
